<div align="center">

[< *Introduction*](1.1.introduction.md) | [**Summary**](0.0.index.md) | [*Pipeline* >](1.3.pipeline.md)

## Documentation

### I.2. Platform - Architecture

</div>

<div align="center">

[Gitlab Arch](#i21-gitlab-architecture) | [Component Arch](#i22-component-base-architecture)  | [Component Makefile](#i23-component-makefile) | [Platform Arch](#i24-platform-architecture)
</div>

### I.2.1. GitLab Architecture

The platform employs a **multi-repository architecture**, which is organized into four primary categories:

- **Infrastructure repositories** — Responsible for deployment, configuration, and orchestration logic.
- **Component repositories** — Contain the platform’s functional modules (e.g., RAG, Auth, etc.).
- **Client repositories** — Define client-specific customizations or integrations.
- **Tool repositories** — Include reusable CI/CD templates, documentation tools, or shared utilities.

The following example illustrates the repository structure:

```bash
.
├── client
├── component
│   ├── auth-gateway
│   ├── inference-runtime
│   ├── lgtm-stack
│   ├── mcp-server
│   └── rag-service
├── infra
│   ├── nixos-deploy
│   └── platform-integration-hub
└── tool
    ├── ci-templates
    └── documentation
```

Each component consists of development **units** (for example, the rag-service includes its own database, server, and multiple microservices). This modularity facilitates independent development, test isolation, and consistent deployment pipelines throughout the system.

> This structure ensures modular development with unified CI/CD and deployment logic.

### I.2.2. Component Base Architecture

All components adhere to a **standardized internal layout** to ensure consistency and automation across CI/CD workflows.

The following example demonstrates the typical directory layout:

```bash
.
├── Makefile            # Root entry point: local-dev, test, CI
├── README.md
├── src/                # Source code and runtime environment
│   ├── [...]           # Individual development units
│   ├── compose.yaml    # Docker service definitions
│   ├── .env.dev        # Development environment variables
│   ├── .env.test       # Testing environment variables
│   └── Makefile
└── test/               # Test scripts and configurations
    ├── e2e             # End-to-end tests
    ├── integration     # Service integration tests
    └── Makefile
```

> A unified structure enables automation tools to build, test, and deploy each component using consistent logic, thereby improving reliability and reducing maintenance overhead.

### I.2.3. Component Makefile

`./Makefile`

The root Makefile functions as the command entry point for each component. It delegates execution to the src and test Makefiles and is intended to remain unmodified, as it is tightly integrated with platform-level automation.

An excerpt of the Makefile is presented below:

```bash
[...]

# Launch the component in development mode
local-dev:
	@$(MAKE) -C $(SRC_DIR) local-dev

# Run integration and end-to-end tests
preview-tests:
	@$(MAKE) -C $(TEST_DIR) integration
	@$(MAKE) -C $(TEST_DIR) e2e

# Push the main branch to the staging branch
main-to-stage:
	[...]
	  git push origin main:stage; \
	[...]

# The e2e test acts as the component’s “unit test” at the platform level
stage-unit-test:
	@$(MAKE) -C $(TEST_DIR) e2e

[...]
```

> These shared rules ensure automation consistency across components and environments (CI, staging, production).

### I.2.4. Platform Architecture

> This section is under development and will describe the logical interaction between components.

<div align="center">

#
[< *Introduction*](1.1.introduction.md) | [**Summary**](0.0.index.md) | [*Pipeline* >](1.3.pipeline.md)